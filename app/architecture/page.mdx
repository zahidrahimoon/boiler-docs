# Architecture

The Next.js Enterprise Starter Kit is built with a modular, scalable architecture that supports enterprise-grade applications. This section covers the core architectural decisions and patterns used throughout the codebase.

## Core Architecture

### Dynamic Layout Engine

The layout system provides complete control over application structure with multiple presets and configurations:

```typescript
// Layout configuration example
const layoutConfig: LayoutConfig = {
  header: {
    enabled: true,
    fixed: false,
    height: "md",
    showLogo: true,
    showNavigation: true,
    showUserMenu: true,
    collapsible: true,
  },
  sidebar: {
    enabled: true,
    position: "left",
    variant: "fixed", // 'drawer' | 'overlay'
    width: "md", // 'sm' | 'lg' | 'xl'
    collapsible: true,
    defaultCollapsed: false,
    showOnMobile: false,
  },
  // ... more configuration
};
```

**Layout Presets:**
- `website` - Marketing/landing pages
- `dashboard` - Admin/analytics interface
- `portal` - User portal with sidebar
- `blog` - Content-focused layout
- `minimal` - Clean, distraction-free

**Key Features:**
- Responsive breakpoints with mobile-first design
- Collapsible sidebar with state persistence
- Multiple sidebar variants (fixed, drawer, overlay)
- RTL/LTR support for internationalization
- Smooth animations and transitions

### Advanced Form System

The form system is built around a universal BaseForm component with automatic validation:

```typescript
// Form configuration
interface FormConfig {
  fields: FieldConfig[];
  validation: ZodSchema;
  layout: 'vertical' | 'horizontal' | 'grid';
  sections?: SectionConfig[];
}

// Field registry with 20+ pre-built components
const fieldRegistry = {
  text: TextInput,
  email: EmailInput,
  password: PasswordInput,
  select: SelectInput,
  multiselect: MultiSelectInput,
  checkbox: CheckboxInput,
  radio: RadioInput,
  textarea: TextareaInput,
  date: DateInput,
  file: FileInput,
  // ... more field types
};
```

**Features:**
- **Schema-Driven**: Zod validation schemas with TypeScript inference
- **Conditional Logic**: Dynamic field visibility based on form state
- **Nested Structures**: Support for sections and repeatable field groups
- **Type Safety**: Full TypeScript support with automatic type inference

### State Management Architecture

The application uses a hybrid approach combining Redux Toolkit and React Query:

```typescript
// Redux store structure
interface RootState {
  ui: UIState;        // Layout, theme, modals
  auth: AuthState;    // User authentication
  app: AppState;      // Application-specific data
}

// React Query for server state
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    },
  },
});
```

**State Management Strategy:**
- **Redux Toolkit**: Client state (UI, auth, app preferences)
- **React Query**: Server state (API data, caching, synchronization)
- **Context Providers**: Layout and error contexts for component communication
- **Redux Persist**: Automatic state persistence with selective hydration

### Real-time Infrastructure

Built-in support for real-time features using Socket.IO and WebSockets:

```typescript
// Socket.IO configuration
const socketConfig = {
  url: process.env.NEXT_PUBLIC_SOCKET_URL,
  options: {
    transports: ['websocket', 'polling'],
    pingInterval: 25000,
    pingTimeout: 5000,
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
  },
};

// Event management with TypeScript
interface SocketEvents {
  connect: () => void;
  disconnect: (reason: string) => void;
  message: (data: MessageData) => void;
  notification: (data: NotificationData) => void;
}
```

**Features:**
- **Bidirectional Communication**: Real-time data exchange
- **Event Management**: Typed event handlers with automatic cleanup
- **Connection Management**: Automatic reconnection and error recovery
- **WebSocket Support**: Native WebSocket implementation for high-frequency updates

## API & Networking

### HTTP Client Configuration

Pre-configured Axios client with interceptors and error handling:

```typescript
// lib/api.ts
const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for authentication
apiClient.interceptors.request.use((config) => {
  const token = getAuthToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Handle unauthorized access
      redirectToLogin();
    }
    return Promise.reject(error);
  }
);
```

**Features:**
- **Request/Response Middleware**: Authentication, error handling, and logging
- **Type-Safe Endpoints**: Generated TypeScript interfaces for API responses
- **Error Normalization**: Consistent error handling across the application
- **Retry Logic**: Automatic retry for failed requests

### Authentication System

Comprehensive authentication flow with multiple verification methods:

```typescript
// Authentication flow
interface AuthFlow {
  login: (credentials: LoginCredentials) => Promise<AuthResponse>;
  logout: () => Promise<void>;
  register: (userData: RegisterData) => Promise<AuthResponse>;
  resetPassword: (email: string) => Promise<void>;
  verifyOTP: (otp: string) => Promise<AuthResponse>;
  refreshToken: () => Promise<AuthResponse>;
}

// Role-based access control
interface User {
  id: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  permissions: Permission[];
}
```

**Features:**
- Email/password login with OTP verification
- Password reset with secure token validation
- Role-based access control (admin/user)
- Cookie-based session management
- Protected routes with middleware
- Auth state persistence across page reloads

## Performance Optimization

### Code Splitting Strategy

Intelligent code splitting for optimal bundle sizes:

```typescript
// Dynamic imports for heavy components
const DashboardCharts = lazy(() => import('./components/DashboardCharts'));
const DataTable = lazy(() => import('./components/DataTable'));

// Route-based splitting
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));

// Component-level splitting with Suspense
<Suspense fallback={<ComponentSkeleton />}>
  <DashboardCharts />
</Suspense>
```

### Bundle Analysis

Built-in tools for analyzing and optimizing bundle size:

```bash
# Analyze bundle size
npm run build
npm run analyze

# Check for duplicate dependencies
npx duplicate-package-checker

# Performance profiling
npm run build:profile
```

### Caching Strategy

Multi-level caching for optimal performance:

```typescript
// React Query caching
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,     // 5 minutes
      cacheTime: 10 * 60 * 1000,    // 10 minutes
      refetchOnWindowFocus: false,
    },
  },
});

// Next.js caching
export const revalidate = 3600; // 1 hour

// Service Worker caching (optional)
const cacheStrategy = {
  static: 'cache-first',
  api: 'network-first',
  images: 'cache-first',
};
```

## Logging System

Client-side logging with Pino for performance and debugging:

```typescript
// Logger configuration
import pino from 'pino';

const logger = pino({
  level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
  browser: {
    asObject: true,
    serialize: true,
  },
  formatters: {
    level: (label) => ({ level: label }),
  },
});

// Usage throughout the application
logger.info('User logged in', { userId, timestamp });
logger.error('API request failed', { error, endpoint });
```

**Features:**
- **Structured Output**: JSON-formatted logs with timestamps and context
- **Performance Focus**: Lightweight, fast logging without runtime impact
- **Browser-Only**: Configured exclusively for client-side use
- **Integration Ready**: Easily extensible for remote logging services

## Security Considerations

### Input Validation

All user inputs are validated using Zod schemas:

```typescript
// Validation schemas
const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

// Runtime validation
const validateInput = (data: unknown, schema: ZodSchema) => {
  try {
    return schema.parse(data);
  } catch (error) {
    throw new ValidationError('Invalid input', error.errors);
  }
};
```

### XSS Protection

Built-in protection against cross-site scripting:

```typescript
// Content Security Policy
const cspHeader = `
  default-src 'self';
  script-src 'self' 'unsafe-eval' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' blob: data:;
  font-src 'self';
  connect-src 'self' ws: wss:;
`;
```

### Authentication Security

Secure authentication implementation:

- JWT tokens with short expiration times
- Secure HTTP-only cookies
- CSRF protection
- Rate limiting on auth endpoints
- Password hashing with bcrypt

## Testing Architecture

Comprehensive testing setup with multiple testing strategies:

```typescript
// Component testing
describe('Button Component', () => {
  it('renders with correct variant', () => {
    render(<Button variant="primary">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('btn-primary');
  });
});

// API testing
describe('Authentication API', () => {
  it('should login successfully', async () => {
    const mockResponse = { token: 'abc123', user: { id: 1 } };
    mockAxios.post.mockResolvedValue({ data: mockResponse });
    
    const result = await authAPI.login('user@example.com', 'password');
    expect(result).toEqual(mockResponse);
  });
});
```

**Testing Strategy:**
- **Unit Tests**: Individual component and function testing
- **Integration Tests**: API integration and component interaction
- **E2E Tests**: Critical user flows and authentication
- **Performance Tests**: Bundle size and runtime performance

This architecture provides a solid foundation for building scalable, maintainable enterprise applications. The modular design allows you to customize and extend functionality while maintaining code quality and performance standards.