# Core Systems

The Next.js Enterprise Starter Kit includes several core systems that work together to provide a comprehensive development platform. This section details each system and how to use them effectively.

## Dynamic Layout System

The layout system is the foundation of the application's UI structure, providing flexible and configurable layouts for different use cases.

### Layout Configuration

```typescript
interface LayoutConfiguration {
  header: HeaderConfig;
  sidebar: SidebarConfig;
  footer: FooterConfig;
  content: ContentConfig;
  navigation: LayoutNavigationConfig;
  responsive: ResponsiveConfig;
}

// Example configuration
const dashboardLayout: LayoutConfiguration = {
  header: {
    enabled: true,
    fixed: true,
    height: "lg",
    showLogo: true,
    showNavigation: true,
    showUserMenu: true,
    showSearch: true,
  },
  sidebar: {
    enabled: true,
    position: "left",
    variant: "fixed",
    width: "md",
    collapsible: true,
    defaultCollapsed: false,
    showOnMobile: true,
  },
  footer: {
    enabled: true,
    fixed: false,
    showLinks: true,
    showCopyright: true,
  },
};
```

### Layout Presets

The system includes several pre-configured layout presets:

#### Website Layout
Perfect for marketing pages and public-facing content:
```typescript
const websiteLayout = {
  header: { enabled: true, fixed: false },
  sidebar: { enabled: false },
  footer: { enabled: true, showLinks: true },
  content: { maxWidth: "7xl", padding: "lg" },
};
```

#### Dashboard Layout
Optimized for admin interfaces and data visualization:
```typescript
const dashboardLayout = {
  header: { enabled: true, fixed: true },
  sidebar: { enabled: true, variant: "fixed" },
  footer: { enabled: false },
  content: { maxWidth: "full", padding: "md" },
};
```

#### Portal Layout
Ideal for user portals and application interfaces:
```typescript
const portalLayout = {
  header: { enabled: true, showUserMenu: true },
  sidebar: { enabled: true, variant: "drawer" },
  footer: { enabled: true, minimal: true },
  content: { maxWidth: "6xl", padding: "lg" },
};
```

### Using Layouts

```typescript
// In your page component
import { useLayout } from '@/hooks/useLayout';

export default function DashboardPage() {
  const { setLayout } = useLayout();
  
  useEffect(() => {
    setLayout('dashboard');
  }, [setLayout]);

  return (
    <div>
      {/* Your page content */}
    </div>
  );
}
```

### Responsive Behavior

The layout system automatically adapts to different screen sizes:

```typescript
const responsiveConfig = {
  breakpoints: {
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px',
  },
  behavior: {
    sidebar: {
      sm: 'overlay',
      md: 'drawer',
      lg: 'fixed',
    },
    header: {
      sm: 'fixed',
      md: 'fixed',
      lg: 'static',
    },
  },
};
```

## Authentication System

Comprehensive authentication with multiple verification methods and role-based access control.

### Authentication Flow

```typescript
// Login process
const loginFlow = async (credentials: LoginCredentials) => {
  try {
    // 1. Submit credentials
    const response = await authAPI.login(credentials);
    
    // 2. Handle OTP verification if required
    if (response.requiresOTP) {
      const otpCode = await promptForOTP();
      await authAPI.verifyOTP(otpCode);
    }
    
    // 3. Store authentication state
    dispatch(setAuthState(response.user));
    
    // 4. Redirect to dashboard
    router.push('/dashboard');
  } catch (error) {
    handleAuthError(error);
  }
};
```

### Role-Based Access Control

```typescript
// Define user roles and permissions
interface User {
  id: string;
  email: string;
  role: UserRole;
  permissions: Permission[];
}

type UserRole = 'admin' | 'user' | 'moderator';

interface Permission {
  resource: string;
  actions: ('create' | 'read' | 'update' | 'delete')[];
}

// Check permissions
const hasPermission = (user: User, resource: string, action: string) => {
  return user.permissions.some(
    permission => 
      permission.resource === resource && 
      permission.actions.includes(action)
  );
};

// Protect components
const ProtectedComponent = ({ children, requiredPermission }) => {
  const { user } = useAuth();
  
  if (!hasPermission(user, requiredPermission.resource, requiredPermission.action)) {
    return <AccessDenied />;
  }
  
  return children;
};
```

### Protected Routes

```typescript
// Middleware for route protection
export function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token');
  const isAuthPage = request.nextUrl.pathname.startsWith('/auth');
  const isProtectedPage = request.nextUrl.pathname.startsWith('/dashboard');

  if (isProtectedPage && !token) {
    return NextResponse.redirect(new URL('/auth/login', request.url));
  }

  if (isAuthPage && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

## Form System

Advanced form builder with type-safe validation and dynamic field generation.

### BaseForm Component

```typescript
interface BaseFormProps<T> {
  schema: ZodSchema<T>;
  fields: FieldConfig[];
  onSubmit: (data: T) => void | Promise<void>;
  defaultValues?: Partial<T>;
  layout?: 'vertical' | 'horizontal' | 'grid';
  sections?: SectionConfig[];
}

// Usage example
const userFormSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email format'),
  role: z.enum(['admin', 'user']),
  preferences: z.object({
    notifications: z.boolean(),
    theme: z.enum(['light', 'dark']),
  }),
});

const UserForm = () => {
  const handleSubmit = async (data: UserFormData) => {
    await userAPI.create(data);
  };

  return (
    <BaseForm
      schema={userFormSchema}
      fields={userFormFields}
      onSubmit={handleSubmit}
      layout="grid"
    />
  );
};
```

### Field Types

The form system includes 20+ pre-built field components:

```typescript
const fieldRegistry = {
  // Text inputs
  text: TextInput,
  email: EmailInput,
  password: PasswordInput,
  textarea: TextareaInput,
  
  // Selection inputs
  select: SelectInput,
  multiselect: MultiSelectInput,
  checkbox: CheckboxInput,
  radio: RadioInput,
  
  // Date and time
  date: DateInput,
  datetime: DateTimeInput,
  time: TimeInput,
  
  // File handling
  file: FileInput,
  image: ImageInput,
  
  // Numeric inputs
  number: NumberInput,
  currency: CurrencyInput,
  percentage: PercentageInput,
  
  // Advanced inputs
  richtext: RichTextEditor,
  code: CodeEditor,
  color: ColorPicker,
};
```

### Dynamic Field Configuration

```typescript
interface FieldConfig {
  name: string;
  type: keyof typeof fieldRegistry;
  label: string;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  conditional?: ConditionalConfig;
  validation?: ZodSchema;
  options?: OptionConfig[];
  grid?: GridConfig;
}

// Conditional field visibility
const conditionalField: FieldConfig = {
  name: 'companyName',
  type: 'text',
  label: 'Company Name',
  conditional: {
    field: 'userType',
    operator: 'equals',
    value: 'business',
  },
};
```

### Form Sections

Organize complex forms with sections:

```typescript
interface SectionConfig {
  title: string;
  description?: string;
  fields: string[];
  collapsible?: boolean;
  defaultCollapsed?: boolean;
}

const userFormSections: SectionConfig[] = [
  {
    title: 'Personal Information',
    description: 'Basic user details',
    fields: ['name', 'email', 'phone'],
  },
  {
    title: 'Account Settings',
    description: 'Account configuration',
    fields: ['role', 'permissions', 'status'],
    collapsible: true,
  },
  {
    title: 'Preferences',
    description: 'User preferences and settings',
    fields: ['theme', 'notifications', 'language'],
    collapsible: true,
    defaultCollapsed: true,
  },
];
```

## Dashboard Module

Real-time analytics dashboard with comprehensive data visualization.

### Dashboard Components

#### Metrics Section
Display key performance indicators:

```typescript
interface MetricConfig {
  title: string;
  value: number | string;
  change?: number;
  changeType?: 'increase' | 'decrease';
  format?: 'number' | 'currency' | 'percentage';
  icon?: React.ComponentType;
}

const MetricsSection = ({ metrics }: { metrics: MetricConfig[] }) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      {metrics.map((metric, index) => (
        <MetricCard key={index} {...metric} />
      ))}
    </div>
  );
};
```

#### Charts Section
Interactive data visualization:

```typescript
import { LineChart, BarChart, PieChart, AreaChart } from 'recharts';

interface ChartConfig {
  type: 'line' | 'bar' | 'pie' | 'area';
  data: any[];
  xAxis?: string;
  yAxis?: string;
  title: string;
  height?: number;
}

const ChartsSection = ({ charts }: { charts: ChartConfig[] }) => {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      {charts.map((chart, index) => (
        <ChartCard key={index} {...chart} />
      ))}
    </div>
  );
};
```

#### Data Tables
Sortable and filterable data grids:

```typescript
interface DataTableConfig<T> {
  data: T[];
  columns: ColumnDef<T>[];
  pagination?: boolean;
  sorting?: boolean;
  filtering?: boolean;
  selection?: boolean;
}

const DataTable = <T,>({ data, columns, ...config }: DataTableConfig<T>) => {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  return (
    <div className="space-y-4">
      <DataTableToolbar table={table} />
      <DataTableContent table={table} />
      <DataTablePagination table={table} />
    </div>
  );
};
```

### Real-time Updates

Dashboard components automatically update with real-time data:

```typescript
const useDashboardData = () => {
  const { data: metrics } = useQuery({
    queryKey: ['dashboard', 'metrics'],
    queryFn: dashboardAPI.getMetrics,
    refetchInterval: 30000, // Refetch every 30 seconds
  });

  // Socket.IO for real-time updates
  useSocket('metrics:update', (newMetrics) => {
    queryClient.setQueryData(['dashboard', 'metrics'], newMetrics);
  });

  return { metrics };
};
```

## State Management

Hybrid state management using Redux Toolkit and React Query.

### Redux Store Structure

```typescript
interface RootState {
  ui: UIState;
  auth: AuthState;
  app: AppState;
}

// UI State - Layout, theme, modals
interface UIState {
  layout: LayoutConfig;
  theme: 'light' | 'dark' | 'system';
  sidebar: {
    collapsed: boolean;
    variant: 'fixed' | 'drawer' | 'overlay';
  };
  modals: {
    [key: string]: boolean;
  };
}

// Auth State - User authentication
interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  permissions: Permission[];
}

// App State - Application-specific data
interface AppState {
  preferences: UserPreferences;
  notifications: Notification[];
  cache: Record<string, any>;
}
```

### React Query Integration

```typescript
// Query client configuration
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      refetchOnWindowFocus: false,
      retry: (failureCount, error) => {
        if (error.status === 404) return false;
        return failureCount < 3;
      },
    },
    mutations: {
      onError: (error) => {
        toast.error(`Operation failed: ${error.message}`);
      },
    },
  },
});

// Custom hooks for data fetching
const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: userAPI.getAll,
  });
};

const useCreateUser = () => {
  return useMutation({
    mutationFn: userAPI.create,
    onSuccess: () => {
      queryClient.invalidateQueries(['users']);
      toast.success('User created successfully');
    },
  });
};
```

### State Persistence

```typescript
// Redux Persist configuration
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['ui', 'auth'], // Only persist UI and auth state
  transforms: [
    // Transform sensitive data before persisting
    createTransform(
      (inboundState: AuthState) => ({
        ...inboundState,
        token: null, // Don't persist tokens
      }),
      (outboundState: AuthState) => outboundState,
      { whitelist: ['auth'] }
    ),
  ],
};
```

These core systems work together to provide a robust foundation for enterprise applications. Each system is designed to be modular and extensible, allowing you to customize functionality while maintaining consistency and performance.